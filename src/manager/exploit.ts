import utilities from "../utils/utilities";

declare global {
  interface ExploitMemory {
    lairs?: { id: Id<StructureKeeperLair> }[];
    pathToRoom?: unknown;
    closestLairToEntrance?: unknown;
  }

  interface Memory {
    exploits: Record<string, ExploitMemory>;
  }
}

export default class Exploit {
  protected units: Record<string, Creep[]>;
  protected name: string;
  protected roomName: string;
  protected flag: Flag;
  protected sourceRoom: Room;
  protected memory: ExploitMemory;
  protected numConstructionSites?: number;

  /**
   * Manages an exploit operation for source keeper rooms.
   * @constructor
   *
   * @param {Room} room
   *   The room that will spawn our creeps and reap the spoils of this operation.
   * @param {string} flagName
   *   Name of the flag pointing to the target source keeper room.
   */
  public constructor(room: Room, flagName: string) {
    const flag = Game.flags[flagName];
    const roomName = flag.pos.roomName;
    this.units = {};
    this.name = roomName;
    this.roomName = roomName;
    this.flag = flag;

    this.sourceRoom = room;

    // Prepare memory
    if (!Memory.exploits) {
      Memory.exploits = {};
    }

    if (!Memory.exploits[roomName]) {
      Memory.exploits[roomName] = {};
    }

    this.memory = Memory.exploits[roomName];

    // Adjust flag color.
    if (this.flag.color !== COLOR_RED) {
      this.flag.setColor(COLOR_RED);
    }

    this.collectCreeps();
    this.collectLairs();
    this.collectSources();

    // Cache paths around the room.
    this.calculatePaths();

    // Save closest lair to entrance point.
    if (this.memory.lairs && this.memory.pathToRoom && !this.memory.closestLairToEntrance) {
      const lastPos = utilities.decodePosition(this.memory.pathToRoom[this.memory.pathToRoom.length - 1]);
      let bestRange = null;
      let best = null;
      for (const lairData of this.memory.lairs) {
        const lair = Game.getObjectById(lairData.id);
        if (lair && (!best || lastPos.getRangeTo(lair) < bestRange)) {
          best = lairData.id;
          bestRange = lastPos.getRangeTo(lair);
        }
      }

      if (best) {
        this.memory.closestLairToEntrance = best;
      }
    }

    // Try and build roads where needed.
    this.buildRoads();
  }

  /**
   * Collects creeps from temp data.
   */
  public collectCreeps() {
    if (Game.exploitTemp && Game.exploitTemp[this.name]) {
      for (const id of Game.exploitTemp[this.name]) {
        const creep = Game.getObjectById(id);

        if (!this.units[creep.memory.exploitUnitType]) {
          this.units[creep.memory.exploitUnitType] = [];
        }

        this.units[creep.memory.exploitUnitType].push(creep);
      }
    }
  }

  /**
   * Collects source keeper lair positions.
   */
  public collectLairs() {
    // @toto Update to roomIntel api.
    if (!this.memory.lairs && Memory.rooms[this.roomName] && Memory.rooms[this.roomName].intel) {
      const intel = Memory.rooms[this.roomName].intel;
      const lairs = intel.structures[STRUCTURE_KEEPER_LAIR];
      if (lairs) {
        this.memory.lairs = [];
        for (const id of _.keys(lairs)) {
          this.memory.lairs.push({
            id,
            paths: {}
          });
        }
      }
    }
  }

  /**
   * Collects sources belonging to lairs.
   */
  public collectSources() {
    if (!this.memory.lairs) return;
    if (this.memory.sourcesChecked && !hivemind.hasIntervalPassed(5000, this.memory.sourcesChecked)) return;

    let found = false;
    for (const lairData of this.memory.lairs) {
      const lair = Game.getObjectById(lairData.id);
      if (!lair) break;

      // Check sources.
      let sources = lair.pos.findInRange(FIND_SOURCES, 7);
      if (sources.length === 0) {
        sources = lair.pos.findInRange(FIND_MINERALS, 7);
      }

      for (const source of sources) {
        lairData.source = source.id;
        lairData.sourceType = source.mineralType || RESOURCE_ENERGY;
        break;
      }

      found = true;
    }

    if (found) {
      this.memory.sourcesChecked = Game.time;
    }
  }

  /**
   * Builds roads in the exploited room.
   */
  public buildRoads() {
    if (this.memory.lastRoadCheck && !hivemind.hasIntervalPassed(50, this.memory.lastRoadCheck)) return;
    if (_.size(Game.constructionSites) > 75) return;
    if (!Game.rooms[this.roomName]) return;

    const room = Game.rooms[this.roomName];
    this.numConstructionSites = room.find(FIND_CONSTRUCTION_SITES).length;
    this.memory.lastRoadCheck = Game.time;

    this.buildRoadsForPath(this.memory.pathToRoom);

    if (!this.memory.lairs) return;
    const lairMemory = this.memory.lairs;

    for (const lairData of lairMemory) {
      this.buildRoadsForPath(lairData.sourcePath && lairData.sourcePath.path, true);

      for (const id2 of _.map(lairMemory, "id")) {
        this.buildRoadsForPath(lairData.paths[id2] && lairData.paths[id2].path);
      }
    }
  }

  /**
   * Builds roads along a given path, optionally with container at the end.
   *
   * @param {string[]} path
   *   An array of encoded room positions.
   * @param {boolean} addContainer
   *   Whether to build a container near the end of the path.
   */
  public buildRoadsForPath(path, addContainer) {
    if (!path) return;

    for (let i = 0; i < path.length; i++) {
      const pos = utilities.decodePosition(path[i]);
      if (pos.roomName !== this.roomName) continue;

      // Build containers close to sources.
      const buildContainer = addContainer && i === path.length - 2;
      if (!this.tryBuildRoad(pos, buildContainer)) return;
    }
  }

  /**
   * Tries to create a construction site for a road.
   *
   * This method checks if other structures or construction sites exist at this
   * position first, and created no more than 10 construction sites in the room.
   *
   * @param {RoomPosition} pos
   *   The position to create the construction site at.
   * @param {boolean} addContainer
   *   Whether to also build a container at this position.
   *
   * @return {boolean}
   *   True if further construction sites can be created.
   */
  public tryBuildRoad(pos, addContainer) {
    const structures = _.groupBy(pos.lookFor(LOOK_STRUCTURES), "structureType");
    const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

    if (sites.length > 0) return true;
    if (_.size(structures[STRUCTURE_ROAD]) === 0 && pos.createConstructionSite(STRUCTURE_ROAD) === OK) {
      this.numConstructionSites++;
    }

    if (
      addContainer &&
      _.size(structures[STRUCTURE_CONTAINER]) === 0 &&
      pos.createConstructionSite(STRUCTURE_CONTAINER) === OK
    ) {
      this.numConstructionSites++;
    }

    return this.numConstructionSites < 10;
  }

  /**
   * Calculates paths needed in exploit room.
   */
  public calculatePaths() {
    // Calculate path into room.
    if (
      !this.memory.pathToRoom ||
      !this.memory.pathToRoomCalculated ||
      hivemind.hasIntervalPassed(10000, this.memory.pathToRoomCalculated)
    ) {
      const startLocation = this.sourceRoom.getStorageLocation();
      if (!startLocation) return;

      let startPosition = new RoomPosition(startLocation.x, startLocation.y, this.sourceRoom.name);
      if (this.sourceRoom.storage) {
        startPosition = this.sourceRoom.storage.pos;
      }

      const endPosition = new RoomPosition(25, 25, this.flag.pos.roomName);

      const result = utilities.getPath(startPosition, { pos: endPosition, range: 20 });

      if (result) {
        this.memory.pathToRoom = utilities.serializePositionPath(result.path);
        this.memory.pathToRoomCalculated = Game.time;
        delete this.memory.closestLairToEntrance;
      } else {
        console.log("No path found!");
      }

      return;
    }

    const lairMemory = this.memory.lairs;
    for (const lairData of lairMemory) {
      // Calculate paths between source keeper lairs.
      for (const lairData2 of lairMemory) {
        if (lairData.id === lairData2.id) continue;
        if (lairData.paths[lairData2.id]) continue;

        const lair = Game.getObjectById(lairData.id);
        const lair2 = Game.getObjectById(lairData2.id);

        if (!lair || !lair2) continue;

        const result = utilities.getPath(lair.pos, { pos: lair2.pos, range: 1 });

        if (result) {
          lairData.paths[lairData2.id] = {
            path: utilities.serializePositionPath(result.path),
            lastCalculated: Game.time
          };
          lairData2.paths[lairData.id] = {
            reverse: true,
            lastCalculated: Game.time
          };
        } else {
          console.log("No path found!");
        }

        return;
      }

      // Calculate paths between lairs and actual sources.
      if (lairData.source && !lairData.sourcePath) {
        const lair = Game.getObjectById(lairData.id);
        const source = Game.getObjectById(lairData.source);

        if (!lair || !source) continue;

        const result = utilities.getPath(lair.pos, { pos: source.pos, range: 1 });

        if (result) {
          lairData.sourcePath = {
            path: utilities.serializePositionPath(result.path),
            lastCalculated: Game.time
          };
        } else {
          console.log("No path found!");
        }

        return;
      }
    }
  }

  /**
   * Calculates status of sources and whether they may be harvested.
   *
   * @return {Object}
   *   Information about active sources.
   */
  public calculateSourcesState() {
    const sourcesState = {
      pathLength: 0,
      sources: []
    };

    // @todo Also calculate states if room has no lairs.
    if (!this.memory.lairs) return sourcesState;

    // Add data for all active sources.
    const roomPathLength = _.size(this.memory.pathToRoom);
    for (const lairData of this.memory.lairs) {
      const source = Game.getObjectById(lairData.source);
      if (!source || !source.getNearbyContainer()) continue;

      // Regenerating mineral sources are also considered inactive.
      if (source.mineralType && source.mineralAmount <= 0) continue;

      sourcesState.sources.push(source);
      sourcesState.pathLength += roomPathLength;
      if (lairData.id !== this.memory.closestLairToEntrance) {
        const id2 = this.memory.closestLairToEntrance;
        if (lairData.paths[id2] && lairData.paths[id2].path) {
          sourcesState.pathLength += _.size(lairData.paths[id2].path);
        } else {
          sourcesState.pathLength += _.size(this.memory.lairs[id2].paths[lairData.id].path);
        }
      }
    }

    return sourcesState;
  }
}
